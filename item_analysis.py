import pandas as pd
from scipy.stats import pointbiserialr
import matplotlib.pyplot as plt
from reportlab.lib.pagesizes import A4
from reportlab.platypus import (
    BaseDocTemplate, Frame, PageTemplate, Table, TableStyle,
    Paragraph, Spacer, PageBreak, Image as RLImage
)
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch
from reportlab.lib.utils import ImageReader
import os
import tempfile
import datetime

def interpret_difficulty(p):
    if p >= 0.9:
        return "Very Easy"
    elif p >= 0.7:
        return "Easy"
    elif p >= 0.3:
        return "Moderate"
    elif p >= 0.1:
        return "Hard"
    else:
        return "Very Hard"

def interpret_discrimination(r_pb):
    if r_pb is None:
        return "N/A"
    elif r_pb >= 0.3:
        return "Very Good"
    elif r_pb >= 0.2:
        return "Acceptable"
    elif r_pb >= 0.1:
        return "Weak"
    elif r_pb >= 0.0:
        return "Very Weak"
    else:
        return "Negative (Bad)"

def generate_score_histogram(df, output_path):
    plt.figure(figsize=(6, 4))
    scores = 100 * df['total_score'] / df['total_score'].max()
    plt.hist(scores, bins=10, edgecolor='black')
    plt.title('Distribution of Student Scores')
    plt.xlabel('Score (%)')
    plt.ylabel('Number of Students')
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.tight_layout()
    plt.savefig(output_path)
    plt.close()

def generate_pdf(output_path, summary, item_df, histogram_path,
                 heading, subheading, author, course_name, assessment_name,
                 staple_logo_path, uni_logo_path):

    pdf_path = os.path.splitext(output_path)[0] + ".pdf"
    styles = getSampleStyleSheet()
    elements = []

    # Title Page
    elements.append(RLImage(uni_logo_path, width=2 * inch, height=2 * inch, kind='proportional'))
    elements.append(Spacer(1, 24))
    elements.append(RLImage(staple_logo_path, width=1.7 * inch, height=1.7 * inch, kind='proportional'))
    elements.append(Spacer(1, 24))
    elements.append(Paragraph(heading, styles['Title']))
    elements.append(Spacer(1, 6))
    elements.append(Paragraph(subheading, styles['Normal']))
    elements.append(Spacer(1, 6))
    elements.append(Paragraph(f"Assessment: {assessment_name}", styles['Normal']))
    elements.append(Spacer(1, 6))
    elements.append(Paragraph(author, styles['Normal']))
    elements.append(Spacer(1, 24))
    elements.append(Paragraph(
        "Report generated by the S.T.A.P.L.E. system, designed by School of Biosciences' TEL Team, University of Liverpool.",
        styles['Italic']
    ))
    elements.append(PageBreak())

    # Summary Statistics
    elements.append(Paragraph("Summary Statistics", styles['Heading2']))
    for k, v in summary.items():
        elements.append(Paragraph(f"{k}: {v}", styles['Normal']))
    elements.append(Spacer(1, 12))

    # Histogram
    elements.append(Paragraph("Score Distribution", styles['Heading2']))
    elements.append(RLImage(histogram_path, width=400, height=300))
    elements.append(PageBreak())

    # Item Statistics Table
    elements.append(Paragraph("Item Statistics", styles['Heading2']))
    table_data = [item_df.columns.tolist()] + item_df.astype(str).values.tolist()
    table = Table(table_data, repeatRows=1)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor("#003366")),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('FONTSIZE', (0, 1), (-1, -1), 9),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 6),
        ('TOPPADDING', (0, 1), (-1, -1), 4),
        ('GRID', (0, 0), (-1, -1), 0.25, colors.grey),
    ]))
    elements.append(table)
    elements.append(PageBreak())

    # Interpretation Key
    elements.append(Paragraph("Interpretation Key", styles['Heading2']))
    elements.append(Paragraph("<b>Difficulty (p)</b>: Proportion of students who answered the item correctly.", styles['Normal']))
    elements += [Paragraph(f"<b>{label}</b>: {desc}", styles['Normal']) for label, desc in [
        ("Very Easy", "More than 90% of students answered correctly. May not discriminate well."),
        ("Easy", "70–89% correct. Suitable for low-to-mid difficulty testing."),
        ("Moderate", "30–69% correct. Ideal range for most items."),
        ("Hard", "10–29% correct. May challenge most students."),
        ("Very Hard", "Fewer than 10% correct. Possibly too difficult or misleading."),
    ]]
    elements.append(Spacer(1, 12))
    elements.append(Paragraph("<b>Discrimination (r_pb)</b>: Correlation between correct answer and overall performance.", styles['Normal']))
    elements += [Paragraph(f"<b>{label}</b>: {desc}", styles['Normal']) for label, desc in [
        ("Very Good", "Strongly distinguishes high and low performers (r ≥ 0.30)."),
        ("Acceptable", "Useful but not optimal (r = 0.20–0.29)."),
        ("Weak", "Limited differentiation (r = 0.10–0.19)."),
        ("Very Weak", "Little to no value (r = 0.00–0.09)."),
        ("Negative (Bad)", "Inverse relationship — may be flawed or misleading."),
    ]]

    def add_footer(canvas, doc):
        footer_text = "For more information about the S.T.A.P.L.E. system please contact Dr. Robert Treharne (R.Treharne@liverpool.ac.uk)."
        canvas.saveState()
        canvas.setFont('Helvetica-Oblique', 7)
        canvas.setFillColor(colors.grey)
        canvas.drawCentredString(A4[0] / 2, 20, footer_text)

        # STAPLE logo with preserved aspect ratio
        staple_img = ImageReader(staple_logo_path)
        orig_width, orig_height = staple_img.getSize()
        display_width = 45
        aspect = orig_height / orig_width
        display_height = display_width * aspect
        canvas.drawImage(staple_logo_path,
                         A4[0] - display_width - 10,
                         5,
                         width=display_width,
                         height=display_height,
                         mask='auto')
        canvas.drawRightString(A4[0] - display_width - 14, 20, f"Page {doc.page}")
        canvas.restoreState()

    doc = BaseDocTemplate(pdf_path, pagesize=A4)
    frame = Frame(doc.leftMargin, doc.bottomMargin + 30, doc.width, doc.height - 40, id='normal')
    template = PageTemplate(id='with-footer', frames=frame, onPage=add_footer)
    doc.addPageTemplates([template])
    doc.build(elements)

    print(f"\n📄 PDF report saved to: {pdf_path}")

def main():
    file_path = input("Enter the path to the CSV file containing raw answers: ").strip()
    num_questions = int(input("Enter the number of questions to include in the analysis (e.g., 32): "))
    author_name = input("Enter the name of the person generating the report: ").strip()
    course_name = input("Enter the course name: ").strip()
    assessment_name = input("Enter the assessment name: ").strip()

    folder_title = os.path.basename(os.path.dirname(file_path)).replace("_", " ").title()
    report_date = datetime.datetime.now().strftime("%d %B %Y")
    report_heading = "Item Analysis Report"
    report_subheading = f"Course: {course_name}"
    report_author = f"Report generated by {author_name} on {report_date}"

    df = pd.read_csv(file_path)
    answer_rows = df[df['filename'].str.contains("answers", case=False, na=False)]
    if answer_rows.empty:
        print("\n❌ No row found where 'filename' contains 'answers'.")
        print("Here are the first few filenames in your file:")
        print(df['filename'].head(10).to_string(index=False))
        return

    answer_row = answer_rows.iloc[0]
    correct_answers = {
        str(col): answer_row[col]
        for col in df.columns
        if col.isdigit()
    }

    selected_qs = sorted(correct_answers.keys(), key=lambda x: int(x))[:num_questions]
    correct_answers = {q: correct_answers[q] for q in selected_qs}

    df = df[~df['filename'].str.contains("answers", case=False, na=False)].copy()

    for q in correct_answers:
        df[f'Q{q}_correct'] = df[q] == correct_answers[q]

    df['total_score'] = df[[f'Q{q}_correct' for q in correct_answers]].sum(axis=1)

    item_stats = []
    for q in correct_answers:
        correct_col = f'Q{q}_correct'
        difficulty = df[correct_col].mean()
        r_pb = None
        if df[correct_col].nunique() > 1:
            r_pb, _ = pointbiserialr(df[correct_col], df['total_score'])
        item_stats.append({
            'Question': int(q),
            'Difficulty (p)': round(difficulty, 3),
            'Difficulty Label': interpret_difficulty(difficulty),
            'Discrimination (r_pb)': round(r_pb, 3) if r_pb is not None else 'N/A',
            'Discrimination Label': interpret_discrimination(r_pb)
        })

    item_df = pd.DataFrame(item_stats).sort_values(by='Question')
    percent_scores = 100 * df['total_score'] / len(correct_answers)
    summary = {
        "Number of students": len(df),
        "Max score (%)": "100.00",
        "Mean score (%)": round(percent_scores.mean(), 2),
        "Median score (%)": round(percent_scores.median(), 2),
        "Highest score (%)": round(percent_scores.max(), 2),
        "Lowest score (%)": round(percent_scores.min(), 2),
    }

    print("\n=== ITEM ANALYSIS SUMMARY ===")
    for k, v in summary.items():
        print(f"{k}: {v}")

    print("\n=== ITEM STATISTICS ===")
    print(item_df.to_string(index=False))

    output_dir = os.path.dirname(file_path)
    output_csv = os.path.join(output_dir, "item_analysis_output.csv")
    item_df.to_csv(output_csv, index=False)
    print(f"\n✅ CSV saved to: {output_csv}")

    with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as tmp_img:
        histogram_path = tmp_img.name
    generate_score_histogram(df, histogram_path)

    # Convert SVG university logo to PNG if needed
    uni_logo_png = "logo_converted.png"


    generate_pdf(
        output_csv, summary, item_df, histogram_path,
        report_heading, report_subheading, report_author, course_name,
        assessment_name, "staple.png", uni_logo_png
    )

if __name__ == "__main__":
    main()
